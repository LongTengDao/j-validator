{
	"version":
		3,
	"file":
		"j-validator.min.js",
	"sourceRoot":
		"../../src/",
	"sources":
		["version?text","export.ts"],
	"sourcesContent":
		[
			"export default'6.0.0';",
			"import version from './version?text';\nexport { version };\n\nimport TypeError from '.TypeError';\nimport SyntaxError from '.SyntaxError';\nimport RegExp from '.RegExp';\nimport test from '.RegExp.prototype.test';\nimport bind from '.Function.prototype.bind?';\nimport Object_is from '.Object.is?';\nimport create from '.Object.create?=';\nimport isArray from '.Array.isArray?=';\nimport ownKeys from '.Reflect.ownKeys?=';\nimport INFINITY from '.Infinity';\nimport UNDEFINED from '.undefined';\nimport Null_prototype from '.null.prototype';\nimport isRegExp from '.class.isRegExp';\n\nvar test_bind = bind\n\t? /*#__PURE__*/ bind.bind(test)                                                                       \n\t: function (            re        ) {\n\t\treturn function (            string        ) {\n\t\t\treturn test.call(re, string);\n\t\t};\n\t};\n\nvar _INFINITY = -INFINITY;\n\nexport function any ()          { return true; }\nexport function never ()          { return false; }\n\nexport function bigint (value         )          { return typeof value==='bigint'; }\nvar bigint_ = { '!bigint': function (value         )          { return typeof value!=='bigint'; } }['!bigint'];\nexport function symbol (value         )          { return typeof value==='symbol'; }\nvar symbol_ = { '!symbol': function (value         )          { return typeof value!=='symbol'; } }['!symbol'];\nexport function string (value         )          { return typeof value==='string'; }\nvar string_ = { '!string': function (value         )          { return typeof value!=='string'; } }['!string'];\nvar BOOLEAN = { 'boolean': function (value         )          { return value===true || value===false; } }['boolean'];\nexport { BOOLEAN as boolean };\nvar boolean_ = { '!boolean': function (value         )          { return value!==true && value!==false; } }['!boolean'];\nexport function number (value         )          { return typeof value==='number'; }\nvar number_ = { '!number': function (value         )          { return typeof value!=='number'; } }['!number'];\nexport function undefined (value         )          { return value===UNDEFINED; }\nvar undefined_ = { '!undefined': function (value         )          { return value!==UNDEFINED; } }['!undefined'];\n\nvar NULL = { 'null': function (value         )          { return value===null; } }['null'];\nvar NULL_ = { '!null': function (value         )          { return value!==null; } }['!null'];\nvar TRUE = { 'true': function (value         )          { return value===true; } }['true'];\nvar TRUE_ = { '!true': function (value         )          { return value!==true; } }['!true'];\nvar FALSE = { 'false': function (value         )          { return value===false; } }['false'];\nvar FALSE_ = { '!false': function (value         )          { return value!==false; } }['!false'];\n\nexport function Infinity (value         )          { return value===INFINITY; }\nInfinity.valueOf = function (                     )         { return INFINITY; };\nvar Infinity_ = { '!Infinity': function (value         )          { return value!==INFINITY; } }['!Infinity'];\nvar _Infinity = { '-Infinity': function (value         )          { return value===_INFINITY; } }['-Infinity'];\nvar _Infinity_ = { '!-Infinity': function (value         )          { return value!==_INFINITY; } }['!-Infinity'];\n\nexport function NaN (value         )          { return value!==value; }\nvar NaN_ = { '!NaN': function (value         )          { return value===value; } }['!NaN'];\n\nvar O            = Object_is\n\t? function O (value         )          { return Object_is (value, 0); }\n\t: function O (value         )          { return value===0 && 1/value>0; };\nvar O_            = Object_is\n\t? function O_ (value         )          { return !Object_is (value, 0); }\n\t: function O_ (value         )          { return value!==0 || 1/value<0; };\nvar _O            = Object_is\n\t? function _O (value         )          { return Object_is (value, -0); }\n\t: function _O (value         )          { return value===0 && 1/value<0; };\nvar _O_            = Object_is\n\t? function _O_ (value         )          { return !Object_is (value, -0); }\n\t: function _O_ (value         )          { return value!==0 || 1/value>0; };\n\nfunction StringTester (type        , FALSE         )            {\n\tif ( type.global ) { type = RegExp(type.source, type.flags ? type.flags.replace('g', '') : ( type.ignoreCase ? 'i' : '' ) + ( type.multiline ? 'm' : '' )); }\n\tvar type_test = test_bind(type);\n\treturn FALSE\n\t\t? function tester (value         )          { return typeof value!=='string' || !type_test(value); }\n\t\t: function tester (value         )          { return typeof value==='string' && type_test(value); };\n}\n\nfunction OBJECT                   (value         , index        , expectKeys                    , validators                                          )          {\n\tif ( typeof value!=='object' || !value ) { return false; }\n\twhile ( index ) {\n\t\tvar key = expectKeys[--index] ;\n\t\tif ( !validators[key](( value      )[key]) ) { return false; }\n\t}\n\treturn true;\n}\nfunction OBJECT_STRICT                   (value         , index        , expectKeys                    , validators                                          )          {\n\tif ( typeof value!=='object' || !value || isArray(value) ) { return false; }\n\twhile ( index ) {\n\t\tvar key = expectKeys[--index] ;\n\t\tif ( !validators[key](( value      )[key]) ) { return false; }\n\t}\n\tfor ( var keys = ownKeys(value), length         = keys.length; index<length; ++index ) {\n\t\tif ( !( keys[index]  in validators ) ) { return false; }\n\t}\n\treturn true;\n}\nfunction ObjectValidator                   (type   , FALSE         , strict         )            {\n\tvar expectKeys = ownKeys(type).reverse();\n\tvar expectLength         = expectKeys.length;\n\tvar validators = create(Null_prototype)                                   ;\n\tfor ( var index         = expectLength; index; ) {\n\t\tvar key = expectKeys[--index] ;\n\t\tvalidators[key] = is(type[key]);\n\t}\n\treturn strict\n\t\t? FALSE\n\t\t\t? function object (value         )          { return !OBJECT_STRICT   (value, expectLength, expectKeys, validators); }\n\t\t\t: function object (value         )          { return OBJECT_STRICT   (value, expectLength, expectKeys, validators); }\n\t\t: FALSE\n\t\t\t? function object (value         )          { return !OBJECT   (value, expectLength, expectKeys, validators); }\n\t\t\t: function object (value         )          { return OBJECT   (value, expectLength, expectKeys, validators); };\n}\n\nfunction ARRAY (value         , length        , validators                      )          {\n\tif ( !isArray(value) || value.length!==length ) { return false; }\n\tfor ( var index         = 0; index<length; ++index ) {\n\t\tif ( !validators[index] (value[index]) ) { return false; }\n\t}\n\treturn true;\n}\nfunction ArrayValidator (type                    , FALSE         )            {\n\tvar length         = type.length;\n\tvar validators              = [];\n\tfor ( var index         = 0; index<length; ++index ) { validators[index] = is(type[index]); }\n\treturn FALSE\n\t\t? function array (value         )          { return !ARRAY(value, length, validators); }\n\t\t: function array (value         )          { return ARRAY(value, length, validators); };\n}\n\nexport function is (type         )            {\n\treturn typeof type==='function' ? type              :\n\t\ttype===UNDEFINED ? undefined :\n\t\t\ttype===true ? TRUE : type===false ? FALSE :\n\t\t\t\ttype===null ? NULL :\n\t\t\t\t\ttypeof type==='object' ?\n\t\t\t\t\t\t/*#__PURE__*/ isArray(type) ? ArrayValidator(type, false) :\n\t\t\t\t\t\tisRegExp(type) ? /*#__PURE__*/ StringTester(type, false) :\n\t\t\t\t\t\t\tObjectValidator(type          , false, false) :\n\t\t\t\t\t\tO(type) ? O : _O(type) ? _O :\n\t\t\t\t\t\t\ttype!==type ? NaN :\n\t\t\t\t\t\t\t\ttype===INFINITY ? Infinity : type===_INFINITY ? _Infinity :\n\t\t\t\t\t\t\t\t\tfunction isType (value         )          { return value===type; };\n}\nexport function not (type         )            {\n\tif ( typeof type==='function' ) {\n\t\tswitch ( type ) {\n\t\t\tcase undefined: return undefined_;\n\t\t\tcase undefined_: return undefined;\n\t\t\tcase bigint: return bigint_;\n\t\t\tcase bigint_: return bigint;\n\t\t\tcase string: return string_;\n\t\t\tcase string_: return string;\n\t\t\tcase BOOLEAN: return boolean_;\n\t\t\tcase boolean_: return BOOLEAN;\n\t\t\tcase TRUE: return TRUE_;\n\t\t\tcase TRUE_: return TRUE;\n\t\t\tcase FALSE: return FALSE_;\n\t\t\tcase FALSE_: return FALSE;\n\t\t\tcase NULL: return NULL_;\n\t\t\tcase NULL_: return NULL;\n\t\t\tcase number: return number_;\n\t\t\tcase number_: return number;\n\t\t\tcase Infinity: return Infinity_;\n\t\t\tcase Infinity_: return Infinity;\n\t\t\tcase _Infinity: return _Infinity_;\n\t\t\tcase _Infinity_: return _Infinity;\n\t\t\tcase O: return O_;\n\t\t\tcase O_: return O;\n\t\t\tcase _O: return _O_;\n\t\t\tcase _O_: return _O;\n\t\t\tcase symbol: return symbol_;\n\t\t\tcase symbol_: return symbol;\n\t\t}\n\t\treturn function notType (value         )          { return !type(value); };\n\t}\n\treturn type===UNDEFINED ? undefined_ :\n\t\ttype===true ? TRUE_ : type===false ? FALSE_ :\n\t\t\ttype===null ? NULL_ :\n\t\t\t\ttypeof type==='object' ?\n\t\t\t\t\tisArray(type) ? /*#__PURE__*/ ArrayValidator(type, true) :\n\t\t\t\t\t\tisRegExp(type) ? /*#__PURE__*/ StringTester(type, true) :\n\t\t\t\t\t\t\t/*#__PURE__*/ ObjectValidator(type          , true, false) :\n\t\t\t\t\ttype===0 ? O_(type) ? _O_ : O_ :\n\t\t\t\t\t\ttype!==type ? NaN_ :\n\t\t\t\t\t\t\ttype===INFINITY ? Infinity_ : type===_INFINITY ? _Infinity_ :\n\t\t\t\t\t\t\t\tfunction notType (value         )          { return value!==type; };\n}\n\nexport function strict (type        )            {\n\tif ( isArray(type) || isRegExp(type) ) { throw TypeError('strict(argument can not be an array or regExp)'); }\n\treturn /*#__PURE__*/ ObjectValidator(type, false, true);\n}\nstrict.not = function strict_not (type        )            {\n\tif ( isArray(type) || isRegExp(type) ) { throw TypeError('strict.not(argument can not be an array or regExp)'); }\n\treturn /*#__PURE__*/ ObjectValidator(type, true, true);\n};\n\nexport function optional (type         )            {\n\tvar validator            = is(type);\n\treturn function optionalValidator (value         )          { return value===UNDEFINED || validator(value); };\n}\n\nfunction OR (value         , length        , validators                      )          {\n\tfor ( var index         = 0; index<length; ++index ) {\n\t\tif ( validators[index] (value) ) { return true; }\n\t}\n\treturn false;\n}\nexport function or (type         )            {\n\tvar types                     = arguments.length===1 && isArray(type) ? type : arguments;\n\tvar length         = types.length;\n\tvar validators              = [];\n\tfor ( var index         = 0; index<length; ++index ) { validators[index] = is(types[index]); }\n\treturn function or (value         )          { return OR(value, length, validators); };\n}\nfunction AND (value         , length        , validators                      )          {\n\tfor ( var index         = 0; index<length; ++index ) {\n\t\tif ( !validators[index] (value) ) { return false; }\n\t}\n\treturn true;\n}\nexport function and (type         )            {\n\tvar types                     = arguments.length===1 && isArray(type) ? type : arguments;\n\tvar length         = types.length;\n\tvar validators              = [];\n\tfor ( var index         = 0; index<length; ++index ) { validators[index] = is(types[index]); }\n\treturn function and (value         )          { return AND(value, length, validators); };\n}\n\nfunction EVERY (value         , validator           )          {\n\tif ( !isArray(value) ) { return false; }\n\tfor ( var length         = value.length, index         = 0; index<length; ++index ) {\n\t\tif ( !validator(value[index]) ) { return false; }\n\t}\n\treturn true;\n}\nexport function every (type         )            {\n\tvar validator            = is(type);\n\treturn function array (value         )          { return EVERY(value, validator); };\n}\n\n                                                     \n                                          \nfunction TUPLE (value         , rootPatterns          )          {\n\tif ( !isArray(value) ) { return false; }\n\tvar patterns                  = rootPatterns;\n\tvar patternIndex         = patterns.length;\n\tvar subValue          = value[0];\n\tvar subIndex         = 0;\n\tfor ( ; ; ) {\n\t\tvar pattern          = patterns[--patternIndex] ;\n\t\tif ( pattern(subValue) ) {\n\t\t\tpatterns = pattern.rest;\n\t\t\tif ( !patterns ) { return true; }\n\t\t\tpatternIndex = patterns.length;\n\t\t\tsubValue = value[++subIndex];\n\t\t}\n\t\telse if ( !patternIndex ) { return false; }\n\t}\n}\nfunction unshift_call (array                   , item     )       {\n\tvar index         = array.length;\n\tdo { array[index] = array[--index] ; }\n\twhile ( index );\n\tarray[0] = item;\n}\nexport function tuple (template                      ) {\n\tvar raw                    = template.raw;\n\tvar length         = arguments.length - 1;\n\tif ( !length ) { throw SyntaxError('tuple'); }\n\tvar s         = raw[0] ;\n\tvar lastIndexAfterLF         = s.lastIndexOf('\\n') + 1;\n\tif ( !lastIndexAfterLF ) { throw SyntaxError('tuple'); }\n\tvar LEVEL         = s.length - lastIndexAfterLF;\n\tvar index         = 0;\n\tvar allPatterns            = [];\n\tdo { ( allPatterns[index] = is(arguments[++index])            ).rest = null; }\n\twhile ( index<length );\n\tindex = 0;\n\tvar rootPatterns           = [ allPatterns[0]  ];\n\tvar level         = function callee (patterns          , LEVEL        )         {\n\t\twhile ( ++index<length ) {\n\t\t\tvar s         = raw[index] ;\n\t\t\tvar lastIndexAfterLF = s.lastIndexOf('\\n') + 1;\n\t\t\tif ( !lastIndexAfterLF ) { throw SyntaxError('tuple'); }\n\t\t\tvar level = s.length - lastIndexAfterLF;\n\t\t\tif ( level<LEVEL ) { return level; }\n\t\t\tif ( level===LEVEL ) { unshift_call(patterns, allPatterns[index] ); }\n\t\t\telse {\n\t\t\t\tlevel = callee(patterns[0] .rest = [ allPatterns[index]  ], level);\n\t\t\t\tif ( level<LEVEL ) { return level; }\n\t\t\t\tif ( level!==LEVEL ) { throw SyntaxError('tuple'); }\n\t\t\t\tunshift_call(patterns, allPatterns[index] );\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}(rootPatterns, LEVEL);\n\tif ( 0<=level && level<LEVEL ) { throw SyntaxError('tuple'); }\n\treturn function tuple (value         )          { return TUPLE(value, rootPatterns); };\n}\n\nimport Default from '.default?=';\nexport default Default({\n\tis: is, not: not,\n\tand: and, or: or,\n\tbigint: bigint, symbol: symbol, string: string, 'boolean': BOOLEAN, number: number,\n\tundefined: undefined, NaN: NaN, Infinity: Infinity,\n\tevery: every, tuple: tuple,\n\toptional: optional, strict: strict,\n\tany: any, never: never,\n\tversion: version\n});\n\n                                             "
		],
	"names":
		["version","test_bind","bind","test","re","string","call","_INFINITY","INFINITY","any","never","bigint","value","bigint_","symbol","symbol_","string_","BOOLEAN","boolean_","number","number_","undefined","UNDEFINED","undefined_","NULL","NULL_","TRUE","TRUE_","FALSE","FALSE_","Infinity","valueOf","Infinity_","_Infinity","_Infinity_","NaN","NaN_","O","Object_is","O_","_O","_O_","StringTester","type","global","RegExp","source","flags","replace","ignoreCase","multiline","type_test","OBJECT","index","expectKeys","validators","key","OBJECT_STRICT","isArray","keys","ownKeys","length","ObjectValidator","strict","reverse","expectLength","create","Null_prototype","is","ARRAY","ArrayValidator","isRegExp","not","TypeError","optional","validator","OR","or","types","arguments","AND","and","EVERY","every","TUPLE","rootPatterns","patterns","patternIndex","subValue","subIndex","pattern","rest","unshift_call","array","item","tuple","template","raw","SyntaxError","s","lastIndexAfterLF","lastIndexOf","LEVEL","allPatterns","level","callee","_export","Default","boolean"],
	"mappings":
		"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"
}